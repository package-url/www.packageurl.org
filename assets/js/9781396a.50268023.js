"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[133],{2064:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"vers-spec/vers-spec-specification","title":"Specification","description":"\x3c!--","source":"@site/docs/vers-spec/vers-spec-specification.md","sourceDirName":"vers-spec","slug":"/vers-spec/vers-spec-specification","permalink":"/www.packageurl.org/docs/vers-spec/vers-spec-specification","draft":false,"unlisted":false,"editUrl":"https://github.com/package-url/www.packageurl.org/blob/main/website/docs/vers-spec/vers-spec-specification.md","tags":[],"version":"current","frontMatter":{"id":"vers-spec-specification","title":"Specification","sidebar_label":"Specification"},"sidebar":"vers_spec","previous":{"title":"Introduction","permalink":"/www.packageurl.org/docs/vers-spec/vers-spec-introduction"},"next":{"title":"Schemas","permalink":"/www.packageurl.org/docs/vers-spec/vers-spec-schemas"}}');var r=s(4848),t=s(8453);const o={id:"vers-spec-specification",title:"Specification",sidebar_label:"Specification"},a="vers: a mostly universal version range specifier",c={},l=[{value:"Context",id:"context",level:2},{value:"Problem",id:"problem",level:2},{value:"Solution",id:"solution",level:2},{value:"Version range specifier",id:"version-range-specifier",level:2},{value:"Using version range specifiers",id:"using-version-range-specifiers",level:3},{value:"Examples",id:"examples",level:3},{value:"URI scheme",id:"uri-scheme",level:3},{value:"<code>&lt;versioning-scheme&gt;</code>",id:"versioning-scheme",level:3},{value:"<code>&lt;version-constraint&gt;</code>",id:"version-constraint",level:3},{value:"Normalized, canonical representation and validation",id:"normalized-canonical-representation-and-validation",level:2},{value:"Parsing and validating version range specifiers",id:"parsing-and-validating-version-range-specifiers",level:2},{value:"Version constraints simplification",id:"version-constraints-simplification",level:3},{value:"Checking if a version is contained within a range",id:"checking-if-a-version-is-contained-within-a-range",level:3},{value:"Notes and caveats",id:"notes-and-caveats",level:3},{value:"Some of the known versioning schemes",id:"some-of-the-known-versioning-schemes",level:2},{value:"Implementations",id:"implementations",level:2},{value:"Related efforts and alternative",id:"related-efforts-and-alternative",level:2},{value:"Why not reuse existing version range notations?",id:"why-not-reuse-existing-version-range-notations",level:2},{value:"Why not use the OSV Ranges?",id:"why-not-use-the-osv-ranges",level:3},{value:"Why not use the CVE v5 API Ranges?",id:"why-not-use-the-cve-v5-api-ranges",level:3},{value:"Why not use the NVD CPE Ranges?",id:"why-not-use-the-nvd-cpe-ranges",level:3},{value:"Why not use node-semver ranges?",id:"why-not-use-node-semver-ranges",level:3},{value:"Why not use Python PEP-0440 ranges?",id:"why-not-use-python-pep-0440-ranges",level:3},{value:"Why not use RubyGems requirements notation?",id:"why-not-use-rubygems-requirements-notation",level:3},{value:"Why not use fewer comparators with only =, &gt;= and &lt;?",id:"why-not-use-fewer-comparators-with-only---and-",level:3},{value:"Why not use richer comparators such as tilde, caret and star?",id:"why-not-use-richer-comparators-such-as-tilde-caret-and-star",level:3},{value:"Why not use mathematical interval notation for ranges?",id:"why-not-use-mathematical-interval-notation-for-ranges",level:3},{value:"References",id:"references",level:2},{value:"License",id:"license",level:2}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",span:"span",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"vers-a-mostly-universal-version-range-specifier",children:"vers: a mostly universal version range specifier"})}),"\n",(0,r.jsx)(n.p,{children:"This specification is a new syntax for dependency and vulnerable version\nranges."}),"\n",(0,r.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,r.jsx)(n.p,{children:"Software package version ranges and version constraints are essential:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'When resolving the dependencies of a package to express which subset\nof the versions are supported. For instance a dependency or\nrequirement statement such as "I require package foo, version 2.0 or\nlater versions" defines a range of acceptable foo versions.'}),"\n",(0,r.jsx)(n.li,{children:'When stating that a known vulnerability or bug affects a range of\npackage versions. For instance a security advisory such as\n"vulnerability 123 affects package bar, version 3.1 and version 4.2\nbut not version 5" defines a range of vulnerable "bar" package\nversions.'}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:'Version ranges can be replaced by a list enumerating all the versions of\ninterest. But in practice, all the versions may not yet exist when\ndefining an open version range such as "v2.0 or later".'}),"\n",(0,r.jsx)(n.p,{children:"Therefore, a version range is a necessary, compact and practical way to\nreference multiple versions rather than listing all the versions."}),"\n",(0,r.jsx)(n.h2,{id:"problem",children:"Problem"}),"\n",(0,r.jsx)(n.p,{children:"Several version range notations exist and have evolved separately to\nserve the specific needs of each package ecosystem, vulnerability\ndatabases and tools."}),"\n",(0,r.jsx)(n.p,{children:"There is no (mostly) universal notation for version ranges and there is\nno universal way to compare two versions, even though the concepts that\nexist in most version range notations are similar."}),"\n",(0,r.jsxs)(n.p,{children:["Each package type or ecosystem may define their own ranges notation and\nversion comparison semantics for dependencies. And for security\nadvisories, the lack of a portable and compact notation for vulnerable\npackage version ranges means that these ranges may be either ambiguous\nor hard to compute and may be best replaced by complete enumerations of\nall impacted versions, such as in the ",(0,r.jsx)(n.a,{href:"https://nvd.nist.gov/vuln/data-feeds#cpeMatch",children:"NVD CPE Match\nfeed"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Because of this, expressing and resolving a version range is often a\ncomplex, error prone task."}),"\n",(0,r.jsxs)(n.p,{children:["In particular the need for common notation for version has emerged based\non the usage of Package-URLs referencing vulnerable package version\nranges such as in vulnerability databases like\n",(0,r.jsx)(n.a,{href:"https://github.com/nexB/vulnerablecode/",children:"VulnerableCode"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"To better understand the problem, here are some of the many notations\nand conventions in use:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"semver"})," ",(0,r.jsx)(n.a,{href:"https://semver.org/",children:"https://semver.org/"})," is a popular specification to\nstructure version strings, but does not provide a way to express\nversion ranges."]}),"\n",(0,r.jsxs)(n.li,{children:["RubyGems strongly suggests using ",(0,r.jsx)(n.code,{children:"semver"})," for version but does not\nenforce it. As a result some gems use semver while several popular\npackages do not use strict semver. RubyGems uses their own notation\nfor version ranges which looks like the ",(0,r.jsx)(n.code,{children:"node-semver"})," notation with\nsome subtle differences. See\n",(0,r.jsx)(n.a,{href:"https://guides.rubygems.org/patterns/#semantic-versioning",children:"https://guides.rubygems.org/patterns/#semantic-versioning"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"node-semver"})," ranges are used in npm at\n",(0,r.jsx)(n.a,{href:"https://github.com/npm/node-semver#ranges",children:"https://github.com/npm/node-semver#ranges"})," with range semantics\nthat are specific to ",(0,r.jsx)(n.code,{children:"semver"})," versions and npm."]}),"\n",(0,r.jsxs)(n.li,{children:["Dart pub versioning scheme is similar to ",(0,r.jsx)(n.code,{children:"node-semver"})," and the\ndocumentation at ",(0,r.jsx)(n.a,{href:"https://dart.dev/tools/pub/versioning",children:"https://dart.dev/tools/pub/versioning"})," provides a\ncomprehensive coverage of the topic of versioning. Version\nresolution uses its own algorithm."]}),"\n",(0,r.jsxs)(n.li,{children:["Python uses its own version and version ranges notation with notable\npeculiarities on how pre-release and post-release suffixes are used\n",(0,r.jsx)(n.a,{href:"https://www.python.org/dev/peps/pep-0440/",children:"https://www.python.org/dev/peps/pep-0440/"})]}),"\n",(0,r.jsxs)(n.li,{children:["Debian and Ubuntu use their own notation and are remarkable for\ntheir use of ",(0,r.jsx)(n.code,{children:"epochs"})," to disambiguate versions.\n",(0,r.jsx)(n.a,{href:"https://www.debian.org/doc/debian-policy/ch-relationships.html",children:"https://www.debian.org/doc/debian-policy/ch-relationships.html"})]}),"\n",(0,r.jsxs)(n.li,{children:["RPM distros use their own range notation and use epochs like Debian.\n",(0,r.jsx)(n.a,{href:"https://rpm-software-management.github.io/rpm/manual/dependencies.html",children:"https://rpm-software-management.github.io/rpm/manual/dependencies.html"})]}),"\n",(0,r.jsxs)(n.li,{children:["Perl CPAN defines its own version range notation similar to this\nspecification and uses two-segment versions.\n",(0,r.jsx)(n.a,{href:"https://metacpan.org/pod/CPAN::Meta::Spec%5C#Version-Ranges",children:"https://metacpan.org/pod/CPAN::Meta::Spec\\#Version-Ranges"})]}),"\n",(0,r.jsxs)(n.li,{children:["Apache Maven and NuGet use similar math intervals notation using\nbrackets ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Interval_(mathematics)",children:"https://en.wikipedia.org/wiki/Interval_(mathematics)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Apache Maven\n",(0,r.jsx)(n.a,{href:"http://maven.apache.org/enforcer/enforcer-rules/versionRanges.html",children:"http://maven.apache.org/enforcer/enforcer-rules/versionRanges.html"})]}),"\n",(0,r.jsxs)(n.li,{children:["NuGet\n",(0,r.jsx)(n.a,{href:"https://docs.microsoft.com/en-us/nuget/concepts/package-versioning#version-ranges",children:"https://docs.microsoft.com/en-us/nuget/concepts/package-versioning#version-ranges"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["gradle uses Apache Maven notation with some extensions\n",(0,r.jsx)(n.a,{href:"https://docs.gradle.org/current/userguide/single_versions.html",children:"https://docs.gradle.org/current/userguide/single_versions.html"})]}),"\n",(0,r.jsxs)(n.li,{children:["Gentoo and Alpine Linux use comparison operators similar to this\nspecification:\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Gentoo ",(0,r.jsx)(n.a,{href:"https://wiki.gentoo.org/wiki/Version_specifier",children:"https://wiki.gentoo.org/wiki/Version_specifier"})]}),"\n",(0,r.jsxs)(n.li,{children:["Alpine linux\n",(0,r.jsx)(n.a,{href:"https://gitlab.alpinelinux.org/alpine/apk-tools/-/blob/master/src/version.c",children:"https://gitlab.alpinelinux.org/alpine/apk-tools/-/blob/master/src/version.c"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Arch Linux ",(0,r.jsx)(n.a,{href:"https://wiki.archlinux.org/title/PKGBUILD#Dependencies",children:"https://wiki.archlinux.org/title/PKGBUILD#Dependencies"}),"\nuses its own simplified notation for its PKGBUILD depends array and\nuses a modified RPM version comparison."]}),"\n",(0,r.jsxs)(n.li,{children:["Go modules ",(0,r.jsx)(n.a,{href:"https://golang.org/ref/mod#versions",children:"https://golang.org/ref/mod#versions"})," use ",(0,r.jsx)(n.code,{children:"semver"}),"\nversions with specific version resolution algorithms."]}),"\n",(0,r.jsxs)(n.li,{children:["Haskell Package Versioning Policy ",(0,r.jsx)(n.a,{href:"https://pvp.haskell.org/",children:"https://pvp.haskell.org/"}),"\nprovides a notation similar to this specification based on a\nmodified semver with extra notations such as star and caret."]}),"\n",(0,r.jsxs)(n.li,{children:["The NVD ",(0,r.jsx)(n.a,{href:"https://nvd.nist.gov/vuln/data-feeds#cpeMatch",children:"https://nvd.nist.gov/vuln/data-feeds#cpeMatch"})," defines CPE\nranges as lists of version start and end either including or\nexcluding the start or end version. And also provides a concrete\nenumeration of the available ranges as a daily feed."]}),"\n",(0,r.jsxs)(n.li,{children:["The version 5 of the CVE JSON data format at\n",(0,r.jsx)(n.a,{href:"https://github.com/CVEProject/cve-schema/blob/master/schema/v5.0/CVE_JSON_5.0.schema#L303",children:"https://github.com/CVEProject/cve-schema/blob/master/schema/v5.0/CVE_JSON_5.0.schema#L303"}),"\ndefines version ranges with a starting version, a versionType, and\nan upper limit for the version range as lessThan or lessThanOrEqual;\nor an enumeration of versions. The versionType is defined as ",(0,r.jsx)(n.code,{children:'"The version numbering system used for specifying the range. This defines the exact semantics of the comparison (less-than) operation on versions, which is required to understand the range itself"'}),'. A\n"versionType" resembles closely the Package-URL package "type".']}),"\n",(0,r.jsxs)(n.li,{children:["The OSSF OSV schema ",(0,r.jsx)(n.a,{href:"https://ossf.github.io/osv-schema/",children:"https://ossf.github.io/osv-schema/"}),' defines\nvulnerable ranges with version events using "introduced", "fixed"\nand "limit" fields and an optional enumeration of all the versions\nin these ranges, except for semver-based versions. A range may be\necosystem-specific based on a provided package "ecosystem" value\nthat resembles closely the Package-URL package "type".']}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The way two versions are compared as equal, lesser or greater is a\nclosely related topic:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Each package ecosystem may have evolved its own peculiar version\nstring conventions, semantics and comparison procedure."}),"\n",(0,r.jsxs)(n.li,{children:["For instance, ",(0,r.jsx)(n.code,{children:"semver"})," is a prominent specification in this domain\nbut this is just one of the many ways to structure a version string."]}),"\n",(0,r.jsx)(n.li,{children:"Debian, RPM, PyPI, RubyGems, and Composer have their own subtly\ndifferent approach to determine how two versions are compared\nas equal, greater or lesser."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"solution",children:"Solution"}),"\n",(0,r.jsx)(n.p,{children:"A solution to the many version range syntaxes is to design a new\nsimplified notation to unify them all with:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"a mostly universal and minimalist, compact notation to express\nversion ranges from many different package types and ecosystems."}),"\n",(0,r.jsx)(n.li,{children:"the package type-specific definitions to normalize existing range\nexpressions in this common notation."}),"\n",(0,r.jsx)(n.li,{children:"the designation of which algorithm or procedure to use when\ncomparing two versions such that it is possible to resolve if a\nversion is within or outside of a version range."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:'We call this solution "version range specifier" or "vers" and it is\ndescribed in this document.'}),"\n",(0,r.jsx)(n.h2,{id:"version-range-specifier",children:"Version range specifier"}),"\n",(0,r.jsxs)(n.p,{children:['A version range specifier (aka. "vers") is a URI string using the ',(0,r.jsx)(n.code,{children:"vers"}),"\nURI-scheme with this syntax:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"vers:<versioning-scheme>/<version-constraint>|<version-constraint>|...\n"})}),"\n",(0,r.jsxs)(n.p,{children:["For example, to define a set of versions that contains either version\n",(0,r.jsx)(n.code,{children:"1.2.3"}),", or any versions greater than or equal to ",(0,r.jsx)(n.code,{children:"2.0.0"})," but less than\n",(0,r.jsx)(n.code,{children:"5.0.0"})," using the ",(0,r.jsx)(n.code,{children:"node-semver"})," versioning scheme used with the ",(0,r.jsx)(n.code,{children:"npm"}),"\nPackage-URL type, the version range specifier will be:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"vers:npm/1.2.3|>=2.0.0|<5.0.0\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"vers"}),' is the URI-scheme and is an acronym for "VErsion Range\nSpecifier". It has been selected because it is short, obviously about\nversion and available for a future formal URI-scheme registration at\nIANA.']}),"\n",(0,r.jsxs)(n.p,{children:['The pipe "|" is used as a simple separator between\n',(0,r.jsx)(n.code,{children:"<version-constraint>"}),". Each ",(0,r.jsx)(n.code,{children:"<version-constraint>"})," in this\npipe-separated list contains a comparator and a version:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<comparator:version>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This list of ",(0,r.jsx)(n.code,{children:"<version-constraint>"})," are signposts in the version\ntimeline of a package that specify version intervals."]}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.code,{children:"<version>"})," satisfies a version range specifier if it is contained\nwithin any of the intervals defined by these ",(0,r.jsx)(n.code,{children:"<version-constraint>"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"using-version-range-specifiers",children:"Using version range specifiers"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"vers"})," primary usage is to test if a version is within a range."]}),"\n",(0,r.jsx)(n.p,{children:"A version is within a version range if falls in any of the intervals\ndefined by a range. Otherwise, the version is outside of the version\nrange."}),"\n",(0,r.jsx)(n.p,{children:"Some important usages derived from this include:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Resolving a version range specifier to a list of concrete\nversions."})," In this case, the input is one or more known versions of\na package. Each version is then tested to check if it lies within or\noutside the range. For example, given a vulnerability and the ",(0,r.jsx)(n.code,{children:"vers"}),"\ndescribing the vulnerable versions of a package, this process is\nused to determine if an existing package version is vulnerable."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Selecting one of several versions that are within a range."})," In\nthis case, given several versions that are within a range and\nseveral packages that express package dependencies qualified by a\nversion range, a package management tool will determine and select\nthe set of package versions that satisfy all the version ranges\nconstraints of all dependencies. This usually requires deploying\nheuristics and algorithms (possibly complex such as sat solvers)\nthat are ecosystem- and tool-specific and outside of the scope for\nthis specification; yet ",(0,r.jsx)(n.code,{children:"vers"})," could be used in tandem with ",(0,r.jsx)(n.code,{children:"purl"}),"\nto provide an input to this dependencies resolution process."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"examples",children:"Examples"}),"\n",(0,r.jsx)(n.p,{children:"A single version in an npm package dependency:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'originally seen as a dependency on version "1.2.3" in a package.json\nmanifest'}),"\n",(0,r.jsxs)(n.li,{children:["the version range spec is: ",(0,r.jsx)(n.code,{children:"vers:npm/1.2.3"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"A list of versions, enumerated:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"vers:pypi/0.0.0|0.0.1|0.0.2|0.0.3|1.0|2.0pre1"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:['A complex statement about a vulnerability in a "maven" package that\naffects multiple branches each with their own fixed versions at\n',(0,r.jsx)(n.a,{href:"https://repo1.maven.org/maven2/org/apache/tomee/apache-tomee/",children:"https://repo1.maven.org/maven2/org/apache/tomee/apache-tomee/"})," Note how\nthe constraints are sorted:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'"affects Apache TomEE 8.0.0-M1 - 8.0.1, Apache TomEE 7.1.0 - 7.1.2,\nApache TomEE 7.0.0-M1 - 7.0.7, Apache TomEE 1.0.0-beta1 - 1.7.5."'}),"\n",(0,r.jsxs)(n.li,{children:["a normalized version range spec is:\n",(0,r.jsx)(n.code,{children:"vers:maven/>=1.0.0-beta1|<=1.7.5|>=7.0.0-M1|<=7.0.7|>=7.1.0|<=7.1.2|>=8.0.0-M1|<=8.0.1"})]}),"\n",(0,r.jsxs)(n.li,{children:["alternatively, four ",(0,r.jsx)(n.code,{children:"vers"})," express the same range, using one ",(0,r.jsx)(n.code,{children:"vers"}),'\nfor each vulnerable "branches":\n',(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"vers:tomee/>=1.0.0-beta1|<=1.7.5"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"vers:tomee/>=7.0.0-M1|<=7.0.7"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"vers:tomee/>=7.1.0|<=7.1.2"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"vers:tomee/>=8.0.0-M1|<=8.0.1"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Converting RubyGems custom syntax for dependency on gem. Note how the\npessimistic version constraint is expanded:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"'library', '~> 2.2.0', '!= 2.2.1'"})}),"\n",(0,r.jsxs)(n.li,{children:["the version range spec is: ",(0,r.jsx)(n.code,{children:"vers:gem/>=2.2.0|!= 2.2.1|<2.3.0"})]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"uri-scheme",children:"URI scheme"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"vers"}),' URI scheme is an acronym for "VErsion Range Specifier". It\nhas been selected because it is short, obviously about version and\navailable for a future formal registration for this URI-scheme at the\nIANA registry.']}),"\n",(0,r.jsx)(n.p,{children:'The URI scheme is followed by a colon ":".'}),"\n",(0,r.jsx)(n.h3,{id:"versioning-scheme",children:(0,r.jsx)(n.code,{children:"<versioning-scheme>"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"<versioning-scheme>"})," (such as ",(0,r.jsx)(n.code,{children:"npm"}),", ",(0,r.jsx)(n.code,{children:"deb"}),", etc.) determines:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"the specific notation and conventions used for a version string\nencoded in this scheme. Versioning schemes often specify a version\nsegments separator and the meaning of each version segment, such as\n[major.minor.patch] in semver."}),"\n",(0,r.jsx)(n.li,{children:"how two versions are compared as greater or lesser to determine if a\nversion is within or outside a range."}),"\n",(0,r.jsxs)(n.li,{children:["how a versioning scheme-specific range notation can be transformed\nin the ",(0,r.jsx)(n.code,{children:"vers"})," simplified notation defined here."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["By convention the versioning scheme ",(0,r.jsx)(n.strong,{children:"should"})," be the same as the\n",(0,r.jsx)(n.code,{children:"Package-URL"})," package type for a given package ecosystem. It is OK to\nhave other schemes beyond the purl type. A scheme could be specific to a\nsingle package name."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"<versioning-scheme>"}),' is followed by a slash "/".']}),"\n",(0,r.jsx)(n.h3,{id:"version-constraint",children:(0,r.jsx)(n.code,{children:"<version-constraint>"})}),"\n",(0,r.jsxs)(n.p,{children:["After the ",(0,r.jsx)(n.code,{children:"<versioning-scheme>"}),' and "/" there are one or more\n',(0,r.jsx)(n.code,{children:"<version-constraint>"}),' separated by a pipe "|". The pipe "|" has no special meaning\nbeside being a separator.']}),"\n",(0,r.jsxs)(n.p,{children:["Each ",(0,r.jsx)(n.code,{children:"<version-constraint>"})," of this list is either a single ",(0,r.jsx)(n.code,{children:"<version>"}),"\nas in ",(0,r.jsx)(n.code,{children:"1.2.3"})," for example or the combination of a ",(0,r.jsx)(n.code,{children:"<comparator>"})," and a\n",(0,r.jsx)(n.code,{children:"<version>"})," as in ",(0,r.jsx)(n.code,{children:">=2.0.0"})," using this syntax:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<comparator><version>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["A single version means that a version equal to this version\nsatisfies the range spec. Equality is based on the equality of two\nnormalized version strings according to their versioning scheme. For\nmost schemes, this is a simple string equality. But schemes can specify\nnormalization and rules for equality such as ",(0,r.jsx)(n.code,{children:"pypi"})," with PEP440."]}),"\n",(0,r.jsxs)(n.p,{children:['The special star "*" comparator matches any version. It must be\nused ',(0,r.jsx)(n.strong,{children:"alone"}),' exclusive of any other constraint and must not be followed\nby a version. For example "vers:deb/*" represents all the versions of a\nDebian package. This includes past, current and possible future\nversions.']}),"\n",(0,r.jsxs)(n.p,{children:["Otherwise, the ",(0,r.jsx)(n.code,{children:"<comparator>"})," is one of these comparison operators:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'"!=": Version exclusion or inequality comparator. This means a\nversion must not be equal to the provided version that must be\nexcluded from the range. For example: "!=1.2.3" means that version\n"1.2.3" is excluded.'}),"\n",(0,r.jsx)(n.li,{children:'"<", "<=": Lesser than or lesser-or-equal version comparators\npoint to all versions less than or equal to the provided version.\nFor example "<=1.2.3" means less than or equal to "1.2.3".'}),"\n",(0,r.jsx)(n.li,{children:'">", ">=": Greater than or greater-or-equal version comparators\npoint to all versions greater than or equal to the provided version.\nFor example ">=1.2.3" means greater than or equal to "1.2.3".'}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"<versioning-scheme>"})," defines:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"how to compare two version strings using these comparators, and"}),"\n",(0,r.jsxs)(n.li,{children:['the structure of a version string such as "1.2.3" if any. For\ninstance, the ',(0,r.jsx)(n.code,{children:"semver"})," specification for version numbers defines a\nversion as composed primarily of three dot-separated numeric\nsegments named major, minor and patch."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"normalized-canonical-representation-and-validation",children:"Normalized, canonical representation and validation"}),"\n",(0,r.jsxs)(n.p,{children:["The construction and validation rules are designed such that a ",(0,r.jsx)(n.code,{children:"vers"})," is\neasier to read and understand by humans and straightforward to process\nby tools, attempting to avoid the creation of empty or impossible\nversion ranges."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'Spaces are not significant and removed in a canonical form. For\nexample "<1.2.3|>=2.0" and " < 1.2. 3 | > = 2 . 0" are equivalent.'}),"\n",(0,r.jsx)(n.li,{children:"A version range specifier contains only printable ASCII letters,\ndigits and punctuation."}),"\n",(0,r.jsxs)(n.li,{children:["The URI scheme and versioning scheme are always lowercase as in\n",(0,r.jsx)(n.code,{children:"vers:npm"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"The versions are case-sensitive, and a versioning scheme may specify\nits own case sensitivity."}),"\n",(0,r.jsxs)(n.li,{children:["If a ",(0,r.jsx)(n.code,{children:"version"})," in a ",(0,r.jsx)(n.code,{children:"<version-constraint>"})," contains separator or\ncomparator characters (i.e. ",(0,r.jsx)(n.code,{children:"><=!*|"}),"), it must be quoted using the\nURL quoting rules. This should be rare in practice."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The list of ",(0,r.jsx)(n.code,{children:"<version-constraint>s"})," of a range are signposts in the\nversion timeline of a package. With these few and simple validation\nrules, we can avoid the creation of most empty or impossible version\nranges:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Constraints are sorted by version"}),". The canonical ordering is the\nversions order. The ordering of ",(0,r.jsx)(n.code,{children:"<version-constraint>"})," is not\nsignificant otherwise but this sort order is needed when checking if a\nversion is contained in a range."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Versions are unique"}),". Each ",(0,r.jsx)(n.code,{children:"version"})," must be unique in a range\nand can occur only once in any ",(0,r.jsx)(n.code,{children:"<version-constraint>"})," of a range\nspecifier, irrespective of its comparators. Tools must report an\nerror for duplicated versions."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"There is only one star"}),': "*" must only occur once and alone in a\nrange, without any other constraint or version.']}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Starting from a de-duplicated and sorted list of constraints, these\nextra rules apply to the comparators of any two contiguous constraints\nto be valid:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'"!=" constraint can be followed by a constraint using any\ncomparator, i.e., any of "=", "!=", ">", ">=", "<", "<=" as\ncomparator (or no constraint).'}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:'Ignoring all constraints with "!=" comparators:'}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'A "=" constraint must be followed only by a constraint with one of\n"=", ">", ">=" as comparator (or no constraint).'}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:'And ignoring all constraints with "=" or "!=" comparators, the sequence\nof constraint comparators must be an alternation of greater and lesser\ncomparators:'}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'"<" and "<=" must be followed by one of ">", ">=" (or no\nconstraint).'}),"\n",(0,r.jsx)(n.li,{children:'">" and ">=" must be followed by one of "<", "<=" (or no\nconstraint).'}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Tools must report an error for such invalid ranges."}),"\n",(0,r.jsx)(n.h2,{id:"parsing-and-validating-version-range-specifiers",children:"Parsing and validating version range specifiers"}),"\n",(0,r.jsx)(n.p,{children:"To parse a version range specifier string:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Remove all spaces and tabs."}),"\n",(0,r.jsx)(n.li,{children:'Start from left, and split once on colon ":".'}),"\n",(0,r.jsxs)(n.li,{children:["The left hand side is the URI-scheme that must be lowercase.\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Tools must validate that the URI-scheme value is ",(0,r.jsx)(n.code,{children:"vers"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"The right hand side is the specifier."}),"\n",(0,r.jsx)(n.li,{children:'Split the specifier from left once on a slash "/".'}),"\n",(0,r.jsxs)(n.li,{children:["The left hand side is the ",(0,r.jsx)(n.code,{children:"<versioning-scheme>"})," that must be\nlowercase. Tools should validate that the ",(0,r.jsx)(n.code,{children:"<versioning-scheme>"})," is a\nknown scheme."]}),"\n",(0,r.jsx)(n.li,{children:"The right hand side is a list of one or more constraints. Tools must\nvalidate that this constraints string is not empty ignoring spaces."}),"\n",(0,r.jsxs)(n.li,{children:['If the constraints string is equal to "*", the\n',(0,r.jsx)(n.code,{children:"<version-constraint>"}),' is "*". Parsing is done and no\nfurther processing is needed for this ',(0,r.jsx)(n.code,{children:"vers"}),'. A tool should report\nan error if there are extra characters beyond "*".']}),"\n",(0,r.jsx)(n.li,{children:'Strip leading and trailing pipes "|" from the constraints string.'}),"\n",(0,r.jsxs)(n.li,{children:['Split the constraints on pipe "|". The result is a list of\n',(0,r.jsx)(n.code,{children:"<version-constraint>"}),". Consecutive pipes must be treated as one and\nleading and trailing pipes ignored."]}),"\n",(0,r.jsxs)(n.li,{children:["For each ",(0,r.jsx)(n.code,{children:"<version-constraint>"}),":\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Determine if the ",(0,r.jsx)(n.code,{children:"<version-constraint>"})," starts with one of the\ntwo comparators:\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'If it starts with ">=", then the comparator is ">=".'}),"\n",(0,r.jsx)(n.li,{children:'If it starts with "<=", then the comparator is "<=".'}),"\n",(0,r.jsx)(n.li,{children:'If it starts with "!=", then the comparator is "!=".'}),"\n",(0,r.jsx)(n.li,{children:'If it starts with "<", then the comparator is "<".'}),"\n",(0,r.jsx)(n.li,{children:'If it starts with ">", then the comparator is ">".'}),"\n",(0,r.jsxs)(n.li,{children:["Remove the comparator from ",(0,r.jsx)(n.code,{children:"<version-constraint>"})," string\nstart. The remaining string is the version."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Otherwise the version is the full ",(0,r.jsx)(n.code,{children:"<version-constraint>"}),' string\n(which implies an equality comparator of "=")']}),"\n",(0,r.jsx)(n.li,{children:"Tools should validate and report an error if the version is\nempty."}),"\n",(0,r.jsx)(n.li,{children:'If the version contains a percent "%" character, apply URL\nquoting rules to unquote this string.'}),"\n",(0,r.jsx)(n.li,{children:"Append the parsed (comparator, version) to the constraints list."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Finally:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The results are the ",(0,r.jsx)(n.code,{children:"<versioning-scheme>"})," and the list of\n",(0,r.jsx)(n.code,{children:"<comparator, version>"})," constraints."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Tools should optionally validate and simplify the list of ",(0,r.jsx)(n.code,{children:"<comparator, version>"})," constraints once parsing is complete:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Sort and validate the list of constraints."}),"\n",(0,r.jsx)(n.li,{children:"Simplify the list of constraints."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"version-constraints-simplification",children:"Version constraints simplification"}),"\n",(0,r.jsxs)(n.p,{children:["Tools can simplify a list of ",(0,r.jsx)(n.code,{children:"<version-constraint>"})," using this approach:"]}),"\n",(0,r.jsx)(n.p,{children:"These pairs of contiguous constraints with these comparators are valid:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"!= followed by anything"}),"\n",(0,r.jsx)(n.li,{children:"=, <, or <= followed by =, !=, >, or >="}),"\n",(0,r.jsx)(n.li,{children:">, or >= followed by !=, <, or <="}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"These pairs of contiguous constraints with these comparators are\nredundant and invalid (ignoring any != since they can show up\nanywhere):"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"=, < or <= followed by < or <=: this is the same as < or <="}),"\n",(0,r.jsx)(n.li,{children:"> or >= followed by =, > or >=: this is the same as > or >="}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"A procedure to remove redundant constraints can be:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Start from a list of constraints of comparator and version, sorted\nby version and where each version occurs only once in any\nconstraint."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"If the constraints list contains a single constraint (star, equal or\nanything) return this list and simplification is finished."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Split the constraints list in two sub lists:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'a list of "unequal constraints" where the comparator is "!="'}),"\n",(0,r.jsx)(n.li,{children:'a remainder list of "constraints" where the comparator is not\n"!="'}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:'If the remainder list of "constraints" is empty, return the "unequal\nconstraints" list and simplification is finished.'}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Iterate over the constraints list, considering the current and next\ncontiguous constraints, and the previous constraint (e.g., before\ncurrent) if it exists:"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:'If current comparator is ">" or ">=" and next comparator is\n"=", ">" or ">=", discard next constraint'}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:'If current comparator is "=", "<" or "<=" and next\ncomparator is <" or <=", discard current constraint.\nPrevious constraint becomes current if it exists.'}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"If there is a previous constraint:"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'If previous comparator is ">" or ">=" and current\ncomparator is "=", ">" or ">=", discard current\nconstraint'}),"\n",(0,r.jsx)(n.li,{children:'If previous comparator is "=", "<" or "<=" and current\ncomparator is <" or <=", discard previous constraint'}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:'Concatenate the "unequal constraints" list and the filtered\n"constraints" list'}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Sort by version and return."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"checking-if-a-version-is-contained-within-a-range",children:"Checking if a version is contained within a range"}),"\n",(0,r.jsx)(n.p,{children:'To check if a "tested version" is contained within a version range:'}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Start from a parsed a version range specifier with:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"a versioning scheme"}),"\n",(0,r.jsx)(n.li,{children:"a list of constraints of comparator and version, sorted by\nversion and where each version occurs only once in any\nconstraint."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:'If the constraint list contains only one item and the comparator is\n"*", then the "tested version" is IN the range. Check is finished.'}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Select the version equality and comparison procedures suitable for\nthis versioning scheme and use these for all version comparisons\nperformed below."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:'If the "tested version" is equal to the any of the constraint\nversions where the constraint comparator is for equality (any of "=",\n"<=", or ">=") then the "tested version" is in the range. Check is\nfinished.'}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:'If the "tested version" is equal to the any of the constraint\nversions where the constraint comparator is "=!" then the "tested\nversion" is NOT in the range. Check is finished.'}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Split the constraint list in two sub lists:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'a first list where the comparator is "=" or "!="'}),"\n",(0,r.jsx)(n.li,{children:'a second list where the comparator is neither "=" nor "!="'}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Iterate over the current and next contiguous constraints pairs (aka.\npairwise) in the second list."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"For each current and next constraint:"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'If this is the first iteration and current comparator is "<"\nor <=" and the "tested version" is less than the current\nversion then the "tested version" is IN the range. Check is\nfinished.'}),"\n",(0,r.jsx)(n.li,{children:'If this is the last iteration and next comparator is ">" or\n>=" and the "tested version" is greater than the next version\nthen the "tested version" is IN the range. Check is finished.'}),"\n",(0,r.jsx)(n.li,{children:'If current comparator is ">" or >=" and next comparator is\n"<" or <=" and the "tested version" is greater than the\ncurrent version and the "tested version" is less than the next\nversion then the "tested version" is IN the range. Check is\nfinished.'}),"\n",(0,r.jsx)(n.li,{children:'If current comparator is "<" or <=" and next comparator is\n">" or >=" then these versions are out the range. Continue\nto the next iteration.'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:'Reaching here without having finished the check before means that\nthe "tested version" is NOT in the range.'}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"notes-and-caveats",children:"Notes and caveats"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Comparing versions from two different versioning schemes is an\nerror. Even though there may be some similarities between the\n",(0,r.jsx)(n.code,{children:"semver"})," version of an npm and the ",(0,r.jsx)(n.code,{children:"deb"})," version of its Debian\npackaging, the way versions are compared specific to each versioning\nscheme and may be different. Tools should report an error in this\ncase."]}),"\n",(0,r.jsx)(n.li,{children:"All references to sorting or ordering of version constraints means\nsorting by version. And sorting by versions always implies using the\nversioning scheme-specified version comparison and ordering."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"some-of-the-known-versioning-schemes",children:"Some of the known versioning schemes"}),"\n",(0,r.jsxs)(n.p,{children:["These are a few known versioning schemes for some common Package-URL\n",(0,r.jsx)(n.span,{className:"title-ref",children:"types"})," (aka. ",(0,r.jsx)(n.code,{children:"ecosystem"}),")."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"deb"}),": Debian and Ubuntu\n",(0,r.jsx)(n.a,{href:"https://www.debian.org/doc/debian-policy/ch-relationships.html",children:"https://www.debian.org/doc/debian-policy/ch-relationships.html"}),"\nDebian uses these comparators: <<, <=, =, >= and >>."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"rpm"}),": RPM distros\n",(0,r.jsx)(n.a,{href:"https://rpm-software-management.github.io/rpm/manual/dependencies.html",children:"https://rpm-software-management.github.io/rpm/manual/dependencies.html"}),"\nA simplified rmpvercmp version comparison routine is used by\nArch Linux Pacman."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"gem"}),": RubyGems\n",(0,r.jsx)(n.a,{href:"https://guides.rubygems.org/patterns/#semantic-versioning",children:"https://guides.rubygems.org/patterns/#semantic-versioning"})," which is\nsimilar to ",(0,r.jsx)(n.code,{children:"node-semver"})," for its syntax, but does not use semver\nversions."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"npm"}),": npm uses node-semver which is based on semver with its own\nrange notation ",(0,r.jsx)(n.a,{href:"https://github.com/npm/node-semver#ranges",children:"https://github.com/npm/node-semver#ranges"})," A similar\nbut different scheme is used by Rust\n",(0,r.jsx)(n.a,{href:"https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html",children:"https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html"}),"\nand several other package types may use ",(0,r.jsx)(n.code,{children:"node-semver"}),"-like ranges.\nBut most of these related schemes are not strictly the same as what\nis implemented in ",(0,r.jsx)(n.code,{children:"node-semver"}),". For instance PHP ",(0,r.jsx)(n.code,{children:"composer"})," may\nneed its own scheme as this is not strictly ",(0,r.jsx)(n.code,{children:"node-semver"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"composer"}),": PHP ",(0,r.jsx)(n.a,{href:"https://getcomposer.org/doc/articles/versions.md",children:"https://getcomposer.org/doc/articles/versions.md"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"pypi"}),": Python ",(0,r.jsx)(n.a,{href:"https://www.python.org/dev/peps/pep-0440/",children:"https://www.python.org/dev/peps/pep-0440/"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cpan"}),": Perl\n",(0,r.jsx)(n.a,{href:"https://perlmaven.com/how-to-compare-version-numbers-in-perl-and-for-cpan-modules",children:"https://perlmaven.com/how-to-compare-version-numbers-in-perl-and-for-cpan-modules"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"golang"}),": Go modules ",(0,r.jsx)(n.a,{href:"https://golang.org/ref/mod#versions",children:"https://golang.org/ref/mod#versions"})," use\n",(0,r.jsx)(n.code,{children:"semver"})," versions with a specific minimum version resolution\nalgorithm."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"maven"}),": Apache Maven supports a math interval notation which is\nrarely seen in practice\n",(0,r.jsx)(n.a,{href:"http://maven.apache.org/enforcer/enforcer-rules/versionRanges.html",children:"http://maven.apache.org/enforcer/enforcer-rules/versionRanges.html"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"nuget"}),": NuGet\n",(0,r.jsx)(n.a,{href:"https://docs.microsoft.com/en-us/nuget/concepts/package-versioning#version-ranges",children:"https://docs.microsoft.com/en-us/nuget/concepts/package-versioning#version-ranges"}),"\nNote that Apache Maven and NuGet are following a similar approach\nwith a math-derived intervals syntax as in\n",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Interval_(mathematics)",children:"https://en.wikipedia.org/wiki/Interval_(mathematics)"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"gentoo"}),": Gentoo ",(0,r.jsx)(n.a,{href:"https://wiki.gentoo.org/wiki/Version_specifier",children:"https://wiki.gentoo.org/wiki/Version_specifier"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"alpine"}),": Alpine linux\n",(0,r.jsx)(n.a,{href:"https://gitlab.alpinelinux.org/alpine/apk-tools/-/blob/master/src/version.c",children:"https://gitlab.alpinelinux.org/alpine/apk-tools/-/blob/master/src/version.c"}),"\nwhich is using Gentoo-like conventions."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"These are generic schemes, to use sparingly for special cases:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"generic"}),": a generic version comparison algorithm (which will be\nspecified later, likely based on a split on any wholly alpha or\nwholly numeric segments and dealing with digit and string\ncomparisons, like is done in libversion)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"none"}),": a generic versioning scheme for a range containing no\nversion. ",(0,r.jsx)(n.code,{children:"vers:none/*"})," is the only valid vers form for this scheme."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"all"}),": a generic versioning scheme for a range containing all\nversions. ",(0,r.jsx)(n.code,{children:"vers:all/*"})," is the only valid vers form for this scheme."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"intdot"}),": a generic versioning scheme that allows version\ncomponents to be specified as integers separated by dots, e.g.\n",(0,r.jsx)(n.code,{children:"10.234.5.12"}),". Versions specified in this scheme consist of ASCII\ndigits only, formatted with only non-negative integers, and ignoring\nleading zeros. Interpretation of the version should stop at the\nfirst character that is not a digit or a dot."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexicographic"}),": a generic versioning scheme that compares\nversions based on lexicographic order, interpreted as UTF-8."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"semver"}),": a generic scheme that uses the same syntax as ",(0,r.jsx)(n.code,{children:"semver"}),".\nIt follows the MAJOR.MINOR.PATCH format and is defined in the\nSemantic Versioning Specification 2.0.0, see\n",(0,r.jsx)(n.a,{href:"https://semver.org/spec/v2.0.0.html",children:"https://semver.org/spec/v2.0.0.html"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"datetime"}),": a generic scheme that uses a timestamp for comparison.\nThe timestamp must adhere to RFC3339, section 5.6, see\n",(0,r.jsx)(n.a,{href:"https://www.rfc-editor.org/rfc/rfc3339#section-5.6",children:"https://www.rfc-editor.org/rfc/rfc3339#section-5.6"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"A separate document will provide details for each versioning scheme and:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["how to convert its native range notation to the ",(0,r.jsx)(n.code,{children:"vers"})," notation and\nback."]}),"\n",(0,r.jsx)(n.li,{children:"how to compare and sort two versions in a range."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["This versioning schemes document will also explain how to convert CVE\nand OSV ranges to ",(0,r.jsx)(n.code,{children:"vers"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"implementations",children:"Implementations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Python: ",(0,r.jsx)(n.a,{href:"https://github.com/nexB/univers",children:"https://github.com/nexB/univers"})]}),"\n",(0,r.jsxs)(n.li,{children:["Java: ",(0,r.jsx)(n.a,{href:"https://github.com/nscuro/versatile",children:"https://github.com/nscuro/versatile"})]}),"\n",(0,r.jsx)(n.li,{children:"Yours!"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"related-efforts-and-alternative",children:"Related efforts and alternative"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["CUDF defines a generic range notation similar to Debian and integer\nversion numbers from the sequence of versions for universal\ndependencies resolution ",(0,r.jsx)(n.a,{href:"https://www.mancoosi.org/cudf/primer/",children:"https://www.mancoosi.org/cudf/primer/"})]}),"\n",(0,r.jsxs)(n.li,{children:['OSV is an "Open source vulnerability DB and triage service." It\ndefines vulnerable version range semantics using a minimal set of\ncomparators for use with package "ecosystem" and version range\n"type". ',(0,r.jsx)(n.a,{href:"https://github.com/google/osv",children:"https://github.com/google/osv"})]}),"\n",(0,r.jsxs)(n.li,{children:["libversion is a library for general purpose version comparison using\na unified procedure designed to work with many package types.\n",(0,r.jsx)(n.a,{href:"https://github.com/repology/libversion",children:"https://github.com/repology/libversion"})]}),"\n",(0,r.jsxs)(n.li,{children:["unified-range is a library for uniform version ranges based on the\nMaven version range spec. It supports Apache Maven and npm ranges\n",(0,r.jsx)(n.a,{href:"https://github.com/snyk/unified-range",children:"https://github.com/snyk/unified-range"})]}),"\n",(0,r.jsxs)(n.li,{children:['dephell specifier is a library to parse and evaluate version ranges\nand "work with version specifiers (can parse PEP-440, SemVer, Ruby,\nNPM, Maven)" ',(0,r.jsx)(n.a,{href:"https://github.com/dephell/dephell_specifier",children:"https://github.com/dephell/dephell_specifier"})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"why-not-reuse-existing-version-range-notations",children:"Why not reuse existing version range notations?"}),"\n",(0,r.jsx)(n.p,{children:"Most existing version range notations are tied to a specific version\nstring syntax and are therefore not readily applicable to other\ncontexts. For example, the use of elements such as tilde and caret\nranges in RubyGems, npm or Dart notations implies that a certain\nstructure exists in the version string (semver or semver- like). The\ninclusion of these additional comparators is a result of the history and\nevolution in a given package ecosystem to address specific needs."}),"\n",(0,r.jsxs)(n.p,{children:["In practice, the unified and reduced set of comparators and syntax\ndefined for ",(0,r.jsx)(n.code,{children:"vers"})," has been designed such that all these notations can\nbe converted to a ",(0,r.jsx)(n.code,{children:"vers"})," and back from a ",(0,r.jsx)(n.code,{children:"vers"})," to the original\nnotation."]}),"\n",(0,r.jsx)(n.p,{children:"In contrast, this would not be possible with existing notations. For\ninstance, the Python notation may not work with npm semver versions and\nreciprocally."}),"\n",(0,r.jsxs)(n.p,{children:["There are likely to be a few rare cases where round tripping from and to\n",(0,r.jsx)(n.code,{children:"vers"})," may not be possible, and in any case round tripping to and from\n",(0,r.jsx)(n.code,{children:"vers"})," should produce equivalent results and even if not strictly the\nsame original strings."]}),"\n",(0,r.jsx)(n.p,{children:'Another issue with existing version range notations is that they are\nprimarily designed for dependencies and not for vulnerable ranges. In\nparticular, a vulnerability may exist for multiple "version branches" of\na given package such as with Django 2.x and 3.x. Several version range\nnotations have difficulties to communicate these as typically all the\nversion constraints must be satisfied. In contrast, a vulnerability can\naffect multiple disjoint version ranges of a package and any version\nsatisfying these constraints would be vulnerable: it may not be possible\nto express this with a notation designed exclusively for dependent\nversions resolution.'}),"\n",(0,r.jsx)(n.p,{children:"Finally, one of the goals of this spec is to be a compact yet obvious\nPackage-URL companion for version ranges. Several existing and closely\nrelated notations designed for vulnerable ranges are verbose\nspecifications designed for use in API with larger JSON documents."}),"\n",(0,r.jsx)(n.h3,{id:"why-not-use-the-osv-ranges",children:"Why not use the OSV Ranges?"}),"\n",(0,r.jsx)(n.p,{children:"See:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://ossf.github.io/osv-schema/",children:"https://ossf.github.io/osv-schema/"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"vers"})," and the OSSF OSV schema vulnerable ranges are equivalent and\n",(0,r.jsx)(n.code,{children:"vers"})," provides a compact range notation while OSV provides a more verbose\nJSON notation."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"vers"})," borrows the design from and was informed by the OSV schema spec\nand its authors."]}),"\n",(0,r.jsx)(n.p,{children:"OSV uses a minimalist set of only three comparators:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'"=" to enumerate versions,'}),"\n",(0,r.jsx)(n.li,{children:'">=" for the version that introduced a vulnerability, and'}),"\n",(0,r.jsx)(n.li,{children:'"<" for the version that fixed a vulnerability.'}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:'OSV Ranges support neither ">" nor "!=" comparators making it\ndifficult to express some ranges that must exclude a version. This may\nnot be an issue for most vulnerable ranges yet:'}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"this makes it difficult or impossible to precisely express certain\ndependency and vulnerable ranges when a version must be excluded and\nthe set of existing versions is not yet known,"}),"\n",(0,r.jsx)(n.li,{children:"this make some ranges more verbose such as with the CVE v5 API\nranges notation that can include their upper limit and would need\ntwo constraints."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:['Another high level difference between the two specifications is the\ncodes used to qualify a range package "ecosystem" value that resembles\nclosely the Package-URL package "type" used in ',(0,r.jsx)(n.code,{children:"vers"}),". This spec will\nprovide a strict mapping between the OSV ecosystem and the ",(0,r.jsx)(n.code,{children:"vers"}),"\nversioning schemes values."]}),"\n",(0,r.jsx)(n.h3,{id:"why-not-use-the-cve-v5-api-ranges",children:"Why not use the CVE v5 API Ranges?"}),"\n",(0,r.jsx)(n.p,{children:"See:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/CVEProject/cve-schema/blob/master/schema/v5.0/CVE_JSON_5.0_schema.json#L303",children:"https://github.com/CVEProject/cve-schema/blob/master/schema/v5.0/CVE_JSON_5.0_schema.json#L303"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/CVEProject/cve-schema/blob/master/schema/v5.0/CVE_JSON_5.0_schema.json#L123",children:"https://github.com/CVEProject/cve-schema/blob/master/schema/v5.0/CVE_JSON_5.0_schema.json#L123"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:['The version 5 of the CVE JSON data format defines version ranges with a\nstarting version, a versionType, and an upper limit for the version\nrange as lessThan or lessThanOrEqual or as an enumeration of versions.\nThe versionType and the package collectionURL possible values are only\nindicative and left out of this specification and both seem strictly\nequivalent to the Package-URL "type" on the one hand and the ',(0,r.jsx)(n.code,{children:"vers"}),"\nversioning scheme on the other hand."]}),"\n",(0,r.jsxs)(n.p,{children:["The semantics and expressiveness of each range are similar and ",(0,r.jsx)(n.code,{children:"vers"}),"\nprovides a compact notation rather than a more verbose JSON notation.\n",(0,r.jsx)(n.code,{children:"vers"})," supports strictly the conversion of any CVE v5 range to its\nnotation and further provides a concrete list of well known versioning\nschemes. ",(0,r.jsx)(n.code,{children:"vers"})," design was informed by the CVE v5 API schema spec and\nits authors."]}),"\n",(0,r.jsxs)(n.p,{children:["When CVE v5 becomes active, this spec will provide a strict mapping\nbetween the CVE ",(0,r.jsx)(n.code,{children:"versionType"})," and the ",(0,r.jsx)(n.code,{children:"vers"}),' versioning schemes values.\nFurthermore, this spec and the Package-URL "types" should be updated\naccordingly to provide a mapping with the upcoming CVE ',(0,r.jsx)(n.code,{children:"collectionURL"}),"\nthat will be effectively used."]}),"\n",(0,r.jsx)(n.p,{children:'There is one issue with CVE v5: it introduces a new trailing "*"\nnotation that does not exist in most version ranges notations and may\nnot be computable easily in many cases. The description of the\n"lessThan" property is:'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'The non-inclusive upper limit of the range. This is the least version\nNOT in the range. The usual version syntax is expanded to allow a\npattern to end in an asterisk <span class="title-ref">(\\*)</span>,\nindicating an arbitrarily large number in the version ordering. For\nexample, <span class="title-ref">{version: 1.0 lessThan: 1.\\*}</span>\nwould describe the entire 1.X branch for most range kinds, and\n<span class="title-ref">{version: 2.0, lessThan: \\*}</span> describes\nall versions starting at 2.0, including 3.0, 5.1, and so on.\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The conversion to ",(0,r.jsx)(n.code,{children:"vers"})," range should be:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["with a version 1.0 and ",(0,r.jsx)(n.span,{className:"title-ref",children:'"lessThan":\n"*"'}),", the ",(0,r.jsx)(n.code,{children:"vers"})," equivalent is: ",(0,r.jsx)(n.code,{children:">=1.0"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["with a version 1.0 and ",(0,r.jsx)(n.span,{className:"title-ref",children:'"lessThan":\n"2.*"'}),", the ",(0,r.jsx)(n.code,{children:"vers"})," equivalent can be computed for ",(0,r.jsx)(n.code,{children:"semver"}),"\nversions as ",(0,r.jsx)(n.code,{children:">=1.0|<2"}),' but this is not accurate because the versioning\nschemes have different rules. For instance, pre-release may be\ntreated in some case as part of the v1. branch and in some other\ncases as part of the v2. branch. It is not clear if with "2.*" the\nCVE v5 spec means:']}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<2"})}),"\n",(0,r.jsxs)(n.li,{children:["or something that excludes any version string that starts with\n",(0,r.jsx)(n.code,{children:"2."})]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["And in this case, with the expression\n",(0,r.jsx)(n.span,{className:"title-ref",children:'"lessThan": "2.*"'})," using a ",(0,r.jsx)(n.code,{children:"semver"}),"\nversion, it is not clear if ",(0,r.jsx)(n.code,{children:"2.0.0-alpha"}),' is "lessThan"; semver sorts it\nbefore ',(0,r.jsx)(n.code,{children:"2.0"})," and after ",(0,r.jsx)(n.code,{children:"1.0"}),", e.g., in ",(0,r.jsx)(n.code,{children:"semver"})," ",(0,r.jsx)(n.code,{children:"2.0.0-alpha"}),' is "less\nthan" ',(0,r.jsx)(n.code,{children:"2"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"why-not-use-the-nvd-cpe-ranges",children:"Why not use the NVD CPE Ranges?"}),"\n",(0,r.jsx)(n.p,{children:"See:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://nvd.nist.gov/vuln/vulnerability-detail-pages#divRange",children:"https://nvd.nist.gov/vuln/vulnerability-detail-pages#divRange"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://nvd.nist.gov/developers/vulnerabilities#divResponse",children:"https://nvd.nist.gov/developers/vulnerabilities#divResponse"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://csrc.nist.gov/schema/nvd/feed/1.1/nvd_cve_feed_json_1.1.schema",children:"https://csrc.nist.gov/schema/nvd/feed/1.1/nvd_cve_feed_json_1.1.schema"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The version ranges notation defined in the JSON schema of the CVE API\npayload uses these four fields: ",(0,r.jsx)(n.code,{children:"versionStartIncluding"}),",\n",(0,r.jsx)(n.code,{children:"versionStartExcluding"}),", ",(0,r.jsx)(n.code,{children:"versionEndIncluding"})," and\n",(0,r.jsx)(n.code,{children:"versionEndExcluding"}),". For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'"versionStartIncluding": "7.3.0",\n"versionEndExcluding": "7.3.31",\n"versionStartExcluding" : "9.0.0",\n"versionEndIncluding" : "9.0.46",\n'})}),"\n",(0,r.jsxs)(n.p,{children:["In addition to these ranges, the NVD publishes a list of concrete CPEs\nwith versions resolved for a range with daily updates at\n",(0,r.jsx)(n.a,{href:"https://nvd.nist.gov/vuln/data-feeds#cpeMatch",children:"https://nvd.nist.gov/vuln/data-feeds#cpeMatch"})]}),"\n",(0,r.jsxs)(n.p,{children:["Note that the NVD CVE configuration is a complex specification that goes\nwell beyond version ranges and is used to match comprehensive\nconfigurations across multiple products and version ranges. ",(0,r.jsx)(n.code,{children:"vers"})," focus\nis exclusively versions."]}),"\n",(0,r.jsxs)(n.p,{children:["In contrast with ",(0,r.jsx)(n.code,{children:"vers"})," compact notation, the NVD JSON notation is more\nverbose, yet ",(0,r.jsx)(n.code,{children:"vers"})," supports strictly the conversion of any CPE range."]}),"\n",(0,r.jsx)(n.h3,{id:"why-not-use-node-semver-ranges",children:"Why not use node-semver ranges?"}),"\n",(0,r.jsx)(n.p,{children:"See:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/npm/node-semver#ranges",children:"https://github.com/npm/node-semver#ranges"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The node-semver spec is similar to but much more complex than this spec.\nThis is an AND of ORs constraints with a few practical issues:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:['A space means "AND", therefore white spaces are significant. Having\nsignificant white spaces in a string makes normalization more\ncomplicated and may be a source of confusion if you remove the\nspaces from the string. ',(0,r.jsx)(n.code,{children:"vers"})," avoids the ambiguity of spaces by\nignoring them."]}),"\n",(0,r.jsx)(n.li,{children:"The advanced range syntax has grown to be rather complex using\nhyphen ranges, stars ranges, carets and tilde constructs that are\nall tied to the JavaScript and npm ways of handling versions in\ntheir ecosystem and are bound furthermore to the semver semantics\nand its npm implementation. These are not readily reusable\nelsewhere. The multiple comparators and modifiers make the notation\ngrammar more complex to parse and process for a machine and harder\nto read for human."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Notations that are directly derived from node-semver as used in Rust and\nPHP Composer have the same issues."}),"\n",(0,r.jsx)(n.h3,{id:"why-not-use-python-pep-0440-ranges",children:"Why not use Python PEP-0440 ranges?"}),"\n",(0,r.jsx)(n.p,{children:"See:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.python.org/dev/peps/pep-0440/#version-specifiers",children:"https://www.python.org/dev/peps/pep-0440/#version-specifiers"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:'The Python pep-0440 "Version Identification and Dependency\nSpecification" provides a comprehensive specification for Python package\nversioning and a notation for "version specifiers" to express the\nversion constraints of dependencies.'}),"\n",(0,r.jsxs)(n.p,{children:["This specification is similar to this ",(0,r.jsx)(n.code,{children:"vers"})," spec, with more operators\nand aspects specific to the versions used only in the Python ecosystem."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"In particular pep-0440 uses tilde, triple equal and wildcard star\noperators that are specific to how two Python versions are compared."}),"\n",(0,r.jsx)(n.li,{children:'The comma separator between constraints is a logical "AND" rather\nthan an "OR". The "OR" does not exist in the syntax making some\nversion ranges harder to express, in particular for vulnerabilities\nthat may affect several exact versions or ranges for multiple\nparallel release branches. Ranges such as "Django 1.2 or later, or\nDjango 2.2 or later or Django 3.2 or later" are difficult to express\nwithout an "OR" logic.'}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"why-not-use-rubygems-requirements-notation",children:"Why not use RubyGems requirements notation?"}),"\n",(0,r.jsx)(n.p,{children:"See:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://guides.rubygems.org/patterns/#declaring-dependencies",children:"https://guides.rubygems.org/patterns/#declaring-dependencies"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The RubyGems specification suggests but does not enforce using semver.\nIt uses operators similar to the ",(0,r.jsx)(n.code,{children:"node-semver"}),' spec with the difference\nof the "~>" aka. pessimistic operator vs. a plain "~" tilde used in\nnode-semver. This operator implies some semver-like versioning, yet gem\nversions are not strictly semver. This makes the notation complex to\nimplement and impractical to reuse in places that do not use the same\nRuby-specific semver-like semantics.']}),"\n",(0,r.jsx)(n.h3,{id:"why-not-use-fewer-comparators-with-only---and-",children:"Why not use fewer comparators with only =, >= and <?"}),"\n",(0,r.jsx)(n.p,{children:"For instance, the OSV schema adopts a reduced set of only three\ncomparators:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'"=" is implied when used to enumerate vulnerable versions'}),"\n",(0,r.jsx)(n.li,{children:'">=" (greater or equal) is for the version that introduces a\nvulnerability'}),"\n",(0,r.jsx)(n.li,{children:'"<" (lesser) is for the version that fixes a vulnerability'}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This approach is simpler and works well for most vulnerable ranges but\nit faces limitations when converting from other notations:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'">" cannot be converted reliably to ">=" unless you know all the\nversions and these will never change.'}),"\n",(0,r.jsx)(n.li,{children:'"<=" cannot be converted reliably to "<" unless you know all the\nversions and these will never change.'}),"\n",(0,r.jsx)(n.li,{children:'"!=" cannot be converted reliably: there is no ">" comparator to\ncreate an unequal equivalent of "><"; and a combo of ">=" and\n"<" is not equivalent to inequality unless you know all the\nversions and these will never change.'}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"why-not-use-richer-comparators-such-as-tilde-caret-and-star",children:"Why not use richer comparators such as tilde, caret and star?"}),"\n",(0,r.jsx)(n.p,{children:"Some existing notations such as used with npm, gem, python, or composer\nprovide syntactic shorthand such as:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'a "pessimistic operator" using tilde, ~> or =~ as in "~1.3" or\n"~>1.2.3"'}),"\n",(0,r.jsx)(n.li,{children:'a caret ^ prefix as in "^ 1.2"'}),"\n",(0,r.jsx)(n.li,{children:'using a star in a version segment as in "1.2.*"'}),"\n",(0,r.jsx)(n.li,{children:'dash-separated ranges as in "1.2 - 1.4"'}),"\n",(0,r.jsx)(n.li,{children:'arbitrary string equality such as "===1.2"'}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Most of these notations can be converted without loss to the ",(0,r.jsx)(n.code,{children:"vers"}),"\nnotation. Furthermore these notations typically assume a well defined\nversion string structure specific to their package ecosystem and are not\nreusable in another ecosystem that would not use the exact same version\nconventions."]}),"\n",(0,r.jsx)(n.p,{children:'For instance, the tilde and caret notations demand that you can reliably\ninfer the next version (aka. "bump") from a given version; this is\npossible only if the versioning scheme supports this operation reliably\nfor all its accepted versions.'}),"\n",(0,r.jsx)(n.h3,{id:"why-not-use-mathematical-interval-notation-for-ranges",children:"Why not use mathematical interval notation for ranges?"}),"\n",(0,r.jsx)(n.p,{children:'Apache Maven and NuGet use a mathematical interval notation with\ncomma-separated "[", "]", "(" and ")" to declare version ranges.'}),"\n",(0,r.jsxs)(n.p,{children:['All other known range notations use the more common ">", "<", and "="\nas comparators. ',(0,r.jsx)(n.code,{children:"vers"})," adopts this familiar approach."]}),"\n",(0,r.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,r.jsx)(n.p,{children:"Here are some of the discussions that led to the creation of this\nspecification:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/package-url/purl-spec/issues/66",children:"https://github.com/package-url/purl-spec/issues/66"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/package-url/purl-spec/issues/84",children:"https://github.com/package-url/purl-spec/issues/84"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/package-url/purl-spec/pull/93",children:"https://github.com/package-url/purl-spec/pull/93"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/nexB/vulnerablecode/issues/119",children:"https://github.com/nexB/vulnerablecode/issues/119"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/nexB/vulnerablecode/issues/140",children:"https://github.com/nexB/vulnerablecode/issues/140"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/nexB/univers/pull/11",children:"https://github.com/nexB/univers/pull/11"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"license",children:"License"}),"\n",(0,r.jsx)(n.p,{children:"This document is licensed under the MIT license"})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var i=s(6540);const r={},t=i.createContext(r);function o(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);